// admin-public/js/libs/leaflet.curve.min.js
// Leaflet.curve - A plugin for Leaflet to draw curved lines using SVG paths
// Based on the original Leaflet.curve plugin

L.Curve = L.Path.extend({
  options: {
    color: 'red',
    weight: 5,
    opacity: 1,
    dashArray: null,
    fillOpacity: 0.2,
    clickable: true
  },

  initialize: function (path, options) {
    L.setOptions(this, options);
    this._setPath(path);
  },

  _setPath: function (path) {
    this._path = path || [];
  },

  getLatLngs: function() {
    return this._latlngs || [];
  },

  setLatLngs: function(latlngs) {
    this._latlngs = latlngs;
    return this.redraw();
  },

  getPathString: function () {
    var path = '';
    
    for (var i = 0; i < this._path.length; i++) {
      if (typeof this._path[i] === 'string') {
        // Command (M, L, Q, etc.)
        path += this._path[i];
        if (i < this._path.length - 1) path += ' ';
      } else if (Array.isArray(this._path[i]) && this._path[i].length === 2) {
        // Coordinate pair
        var point = this._map.latLngToLayerPoint(L.latLng(this._path[i][0], this._path[i][1]));
        path += point.x + ',' + point.y;
        if (i < this._path.length - 1) path += ' ';
      }
    }
    
    return path.trim();
  },

  _update: function () {
    if (!this._map) { return; }

    this._updatePath();
  },

  _updatePath: function () {
    if (!this._renderer) { return; }
    
    var pathString = this.getPathString();
    this._renderer._setPath(this, pathString);
  },

  _project: function() {
    // Project the path points
    this._rings = [];
    if (this._path && this._path.length > 0) {
      var ring = [];
      for (var i = 0; i < this._path.length; i++) {
        if (Array.isArray(this._path[i]) && this._path[i].length === 2) {
          var point = this._map.latLngToLayerPoint(L.latLng(this._path[i][0], this._path[i][1]));
          ring.push(point);
        }
      }
      if (ring.length > 0) {
        this._rings.push(ring);
      }
    }
  },

  _updateBounds: function() {
    if (!this._path || this._path.length === 0) return;
    
    var bounds = new L.LatLngBounds();
    
    for (var i = 0; i < this._path.length; i++) {
      if (Array.isArray(this._path[i]) && this._path[i].length === 2) {
        bounds.extend(L.latLng(this._path[i][0], this._path[i][1]));
      }
    }
    
    this._bounds = bounds;
  },

  getBounds: function() {
    if (!this._bounds) {
      this._updateBounds();
    }
    return this._bounds;
  }
});

// SVG Renderer support for curved paths
if (L.SVG) {
  L.SVG.include({
    _setPath: function (layer, path) {
      if (layer instanceof L.Curve) {
        layer._path.setAttribute('d', path || 'M0 0');
      } else if (layer._path) {
        layer._path.setAttribute('d', path || 'M0 0');
      }
    }
  });
}

// Canvas Renderer support (fallback)
if (L.Canvas) {
  L.Canvas.include({
    _updateCurve: function (layer) {
      if (!layer._path || layer._path.length === 0) return;
      
      var ctx = this._ctx;
      var pathString = layer.getPathString();
      
      // Simple fallback: draw as polyline for canvas
      ctx.beginPath();
      var firstPoint = true;
      
      for (var i = 0; i < layer._path.length; i++) {
        if (Array.isArray(layer._path[i]) && layer._path[i].length === 2) {
          var point = this._map.latLngToLayerPoint(L.latLng(layer._path[i][0], layer._path[i][1]));
          if (firstPoint) {
            ctx.moveTo(point.x, point.y);
            firstPoint = false;
          } else {
            ctx.lineTo(point.x, point.y);
          }
        }
      }
      
      this._fillStroke(ctx, layer);
    }
  });
}

// Factory function
L.curve = function (path, options) {
  return new L.Curve(path, options);
};